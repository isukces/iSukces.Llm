// This file was generated by iSukces.Templates ver 1.26.104.9
// Get the latest version from https://raw.githubusercontent.com/isukces/iSukces.Templates/main/Code/iSukces.Templates/PrimitiveObsession.ttinclude

using Newtonsoft.Json;

namespace iSukces.Llm.Common;

[JsonConverter(typeof(LlmToolParameterTypeJsonConverter))]
public readonly struct LlmToolParameterType: IComparable, IComparable<LlmToolParameterType>, IComparable<string>, IEquatable<LlmToolParameterType>, IEquatable<string>
{
    public LlmToolParameterType(string? value) => _value = value?.Trim();

    public override bool Equals(object? obj) => obj is LlmToolParameterType x && Equals(x);

    public bool Equals(LlmToolParameterType other) => Comparer.Equals(Value, other.Value);

    public override int GetHashCode() => Comparer.GetHashCode(Value);

    public bool Equals(string? other) => Comparer.Equals(Value, other ?? string.Empty);

    public int CompareTo(LlmToolParameterType other) => Comparer.Compare(Value, other.Value);

    public int CompareTo(object? obj)
    {
        if (obj is null) return 1;
        return obj is LlmToolParameterType other
            ? CompareTo(other)
            : throw new ArgumentException($"Object must be of type {nameof(LlmToolParameterType)}");
    }

    public int CompareTo(string? other) => Comparer.Compare(Value, other ?? string.Empty);

    public override string ToString() => Value;

    public static implicit operator LlmToolParameterType(string? value) => new LlmToolParameterType(value);

    public static explicit operator string(LlmToolParameterType value) => value.Value;

    public static bool operator ==(LlmToolParameterType left, LlmToolParameterType right) => left.Equals(right);

    public static bool operator !=(LlmToolParameterType left, LlmToolParameterType right) => !left.Equals(right);

    private readonly string? _value;

    public string Value => _value ?? string.Empty;

    public static LlmToolParameterType Empty { get; } = new LlmToolParameterType(null);

    public bool IsEmpty => string.IsNullOrEmpty(_value);

    public static StringComparer Comparer => StringComparer.Ordinal;

    public static readonly LlmToolParameterType Object = new("object");
    public static readonly LlmToolParameterType String = new("string");
    public static readonly LlmToolParameterType Number = new("number");
}

public sealed class LlmToolParameterTypeJsonConverter : JsonConverter
{
    public override bool CanConvert(Type objectType) => objectType == typeof(LlmToolParameterType);

    public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
    {
        return reader.Value switch
        {
            string stringValue => new LlmToolParameterType(stringValue),
            null => LlmToolParameterType.Empty,
            _ => throw new NotImplementedException()
        };
    }

    public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
    {
        if (value is null)
            throw new NullReferenceException("value is null");
        writer.WriteValue(((LlmToolParameterType)value).Value);
    }

}

[JsonConverter(typeof(AiFinishReasonJsonConverter))]
public readonly struct AiFinishReason: IComparable, IComparable<AiFinishReason>, IComparable<string>, IEquatable<AiFinishReason>, IEquatable<string>
{
    public AiFinishReason(string? value) => _value = value?.Trim();

    public override bool Equals(object? obj) => obj is AiFinishReason x && Equals(x);

    public bool Equals(AiFinishReason other) => Comparer.Equals(Value, other.Value);

    public override int GetHashCode() => Comparer.GetHashCode(Value);

    public bool Equals(string? other) => Comparer.Equals(Value, other ?? string.Empty);

    public int CompareTo(AiFinishReason other) => Comparer.Compare(Value, other.Value);

    public int CompareTo(object? obj)
    {
        if (obj is null) return 1;
        return obj is AiFinishReason other
            ? CompareTo(other)
            : throw new ArgumentException($"Object must be of type {nameof(AiFinishReason)}");
    }

    public int CompareTo(string? other) => Comparer.Compare(Value, other ?? string.Empty);

    public override string ToString() => Value;

    public static explicit operator AiFinishReason(string? value) => new AiFinishReason(value);

    public static explicit operator string(AiFinishReason value) => value.Value;

    public static bool operator ==(AiFinishReason left, AiFinishReason right) => left.Equals(right);

    public static bool operator !=(AiFinishReason left, AiFinishReason right) => !left.Equals(right);

    private readonly string? _value;

    public string Value => _value ?? string.Empty;

    public static AiFinishReason Empty { get; } = new AiFinishReason(null);

    public bool IsEmpty => string.IsNullOrEmpty(_value);

    public static StringComparer Comparer => StringComparer.Ordinal;

    public static readonly AiFinishReason Stop = new("stop");
    public static readonly AiFinishReason Length = new("length");
    public static readonly AiFinishReason ContentFilter = new("content_filter");
    public static readonly AiFinishReason ToolsCall = new("tool_calls");
    public static readonly AiFinishReason Null = new("null");
}

public sealed class AiFinishReasonJsonConverter : JsonConverter
{
    public override bool CanConvert(Type objectType) => objectType == typeof(AiFinishReason);

    public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
    {
        return reader.Value switch
        {
            string stringValue => new AiFinishReason(stringValue),
            null => AiFinishReason.Empty,
            _ => throw new NotImplementedException()
        };
    }

    public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
    {
        if (value is null)
            throw new NullReferenceException("value is null");
        writer.WriteValue(((AiFinishReason)value).Value);
    }

}

[JsonConverter(typeof(ToolChoiceJsonConverter))]
public readonly struct ToolChoice: IComparable, IComparable<string>, IComparable<ToolChoice>, IEquatable<string>, IEquatable<ToolChoice>
{
    public ToolChoice(string? value) => _value = value?.Trim();

    public override bool Equals(object? obj) => obj is ToolChoice x && Equals(x);

    public bool Equals(ToolChoice other) => Comparer.Equals(Value, other.Value);

    public override int GetHashCode() => Comparer.GetHashCode(Value);

    public bool Equals(string? other) => Comparer.Equals(Value, other ?? string.Empty);

    public int CompareTo(ToolChoice other) => Comparer.Compare(Value, other.Value);

    public int CompareTo(object? obj)
    {
        if (obj is null) return 1;
        return obj is ToolChoice other
            ? CompareTo(other)
            : throw new ArgumentException($"Object must be of type {nameof(ToolChoice)}");
    }

    public int CompareTo(string? other) => Comparer.Compare(Value, other ?? string.Empty);

    public override string ToString() => Value;

    public static explicit operator ToolChoice(string? value) => new ToolChoice(value);

    public static explicit operator string(ToolChoice value) => value.Value;

    public static bool operator ==(ToolChoice left, ToolChoice right) => left.Equals(right);

    public static bool operator !=(ToolChoice left, ToolChoice right) => !left.Equals(right);

    private readonly string? _value;

    public string Value => _value ?? string.Empty;

    public static ToolChoice Empty { get; } = new ToolChoice(null);

    public bool IsEmpty => string.IsNullOrEmpty(_value);

    public static StringComparer Comparer => StringComparer.Ordinal;

    public static readonly ToolChoice Auto = new("auto");
}

public sealed class ToolChoiceJsonConverter : JsonConverter
{
    public override bool CanConvert(Type objectType) => objectType == typeof(ToolChoice);

    public override object? ReadJson(JsonReader reader, Type objectType, object? existingValue, JsonSerializer serializer)
    {
        return reader.Value switch
        {
            string stringValue => new ToolChoice(stringValue),
            null => ToolChoice.Empty,
            _ => throw new NotImplementedException()
        };
    }

    public override void WriteJson(JsonWriter writer, object? value, JsonSerializer serializer)
    {
        if (value is null)
            throw new NullReferenceException("value is null");
        writer.WriteValue(((ToolChoice)value).Value);
    }

}

